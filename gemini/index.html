<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Gesture Particles | Three.js + Gemini</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }
        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            overflow: hidden;
            border-radius: 12px;
            border: 2px solid #3b82f6;
            transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black">
        <div class="loader mb-4"></div>
        <p class="text-white font-mono animate-pulse">Initializing MediaPipe & Neural Engines...</p>
    </div>

    <div class="fixed top-6 left-6 z-40 flex flex-col gap-4 pointer-events-none">
        <div class="glass p-6 pointer-events-auto">
            <h1 class="text-white text-xl font-bold mb-1">Gesture Morph v1.0</h1>
            <p id="gesture-label" class="text-blue-400 font-mono text-sm uppercase tracking-widest">Scanning for hands...</p>
            
            <div class="flex items-center gap-4 mt-4">
                <input type="color" id="base-color" value="#ffffff" class="w-8 h-8 bg-transparent cursor-pointer">
                <button onclick="toggleFullscreen()" class="text-xs text-white bg-white/10 px-3 py-1 rounded hover:bg-white/20 transition">FULLSCREEN</button>
            </div>
        </div>

        <button id="ai-magic-btn" class="glass p-4 pointer-events-auto text-left hover:bg-blue-600/20 transition group">
            <span class="text-blue-400 font-bold block group-hover:text-blue-300">âœ¨ AI MAGIC</span>
            <span class="text-gray-400 text-xs italic">Generate shapes with Gemini</span>
        </button>
    </div>

    <div id="ai-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="glass p-8 w-full max-w-md mx-4">
            <h2 class="text-white text-xl mb-4">Gemini Shape Generator</h2>
            <input type="password" id="api-key" placeholder="Enter Gemini API Key" class="w-full bg-black/40 border border-white/10 p-2 text-white rounded mb-4">
            <textarea id="ai-prompt" placeholder="e.g. A double helix DNA spiral" class="w-full bg-black/40 border border-white/10 p-2 text-white rounded mb-4 h-24"></textarea>
            <div class="flex justify-end gap-2">
                <button onclick="closeModal()" class="text-gray-400 px-4 py-2 hover:text-white">Cancel</button>
                <button id="generate-btn" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-500">Generate</button>
            </div>
        </div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const PARTICLE_COUNT = 20000;
        let currentGesture = "none";
        let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        let targetColors = new Float32Array(PARTICLE_COUNT * 3);
        const tempColor = new THREE.Color();

        // --- Core Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Bloom Post-Processing ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.1;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Particle System ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.12,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- Shape Generation Logic ---
        const shapes = {
            rainbowSphere: () => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    targetPositions[i * 3] = 15 * Math.cos(theta) * Math.sin(phi);
                    targetPositions[i * 3 + 1] = 15 * Math.sin(theta) * Math.sin(phi);
                    targetPositions[i * 3 + 2] = 15 * Math.cos(phi);
                    
                    tempColor.setHSL((i / PARTICLE_COUNT), 0.8, 0.6);
                    targetColors[i * 3] = tempColor.r;
                    targetColors[i * 3 + 1] = tempColor.g;
                    targetColors[i * 3 + 2] = tempColor.b;
                }
            },
            heart: () => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const t = Math.random() * Math.PI * 2;
                    // Heart equation
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    
                    targetPositions[i * 3] = x * 0.8;
                    targetPositions[i * 3 + 1] = y * 0.8;
                    targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 5;

                    targetColors[i * 3] = 1; targetColors[i * 3 + 1] = 0.2; targetColors[i * 3 + 2] = 0.5;
                }
            },
            saturn: () => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    if (i < PARTICLE_COUNT * 0.4) { // Central Sphere
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.random() * Math.PI;
                        const r = 6;
                        targetPositions[i * 3] = r * Math.sin(theta) * Math.cos(phi);
                        targetPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                        targetPositions[i * 3 + 2] = r * Math.cos(theta);
                        targetColors[i * 3] = 0.2; targetColors[i * 3 + 1] = 0.4; targetColors[i * 3 + 2] = 1.0;
                    } else { // Rings
                        const angle = Math.random() * Math.PI * 2;
                        const r = 8 + Math.random() * 6;
                        targetPositions[i * 3] = r * Math.cos(angle);
                        targetPositions[i * 3 + 1] = (r * Math.sin(angle)) * 0.5; // Tilted feel
                        targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
                        targetColors[i * 3] = 0.8; targetColors[i * 3 + 1] = 0.7; targetColors[i * 3 + 2] = 0.4;
                    }
                }
            }
        };

        // --- Text Surface Sampling ---
        const fontLoader = new FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (font) => {
            const textGeo = new TextGeometry('I LOVE YOU', { font, size: 4, height: 1.5, curveSegments: 12 });
            textGeo.center();
            const sampler = new MeshSurfaceSampler(new THREE.Mesh(textGeo)).build();
            const tempPos = new THREE.Vector3();

            shapes.text = () => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    sampler.sample(tempPos);
                    targetPositions[i * 3] = tempPos.x;
                    targetPositions[i * 3 + 1] = tempPos.y;
                    targetPositions[i * 3 + 2] = tempPos.z;
                    targetColors[i * 3] = 1.0; targetColors[i * 3 + 1] = 0.84; targetColors[i * 3 + 2] = 0.0;
                }
            };
            document.getElementById('loading-overlay').style.display = 'none';
        });

        // --- Gemini Integration ---
        window.closeModal = () => document.getElementById('ai-modal').classList.add('hidden');
        document.getElementById('ai-magic-btn').onclick = () => document.getElementById('ai-modal').classList.remove('hidden');

        document.getElementById('generate-btn').onclick = async () => {
            const key = document.getElementById('api-key').value;
            const prompt = document.getElementById('ai-prompt').value;
            const btn = document.getElementById('generate-btn');
            
            if(!key || !prompt) return alert("Missing Key or Prompt");
            btn.innerText = "Thinking...";

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `Generate ONLY raw JS code inside a for loop (i from 0 to PARTICLE_COUNT) that sets targetPositions[i*3], targetPositions[i*3+1], targetPositions[i*3+2] and targetColors[i*3], [i*3+1], [i*3+2] for the shape: ${prompt}. Use THREE.MathUtils and standard Math. Do not include triple backticks or "javascript" tag.` }]}]
                    })
                });
                const data = await response.json();
                const code = data.candidates[0].content.parts[0].text;
                
                // Safety: Wrap in function
                shapes.ai = new Function('targetPositions', 'targetColors', 'PARTICLE_COUNT', 'THREE', code);
                currentGesture = "ai";
                closeModal();
            } catch (err) {
                console.error(err);
                alert("API Error. Check console.");
            }
            btn.innerText = "Generate";
        };

        // --- MediaPipe Hand Tracking ---
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        let handLandmarker;
        const video = document.getElementById('webcam');

        const setupHands = async () => {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            startCamera();
        };

        const startCamera = () => {
            navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predict);
            });
        };

        const predict = async () => {
            const results = await handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks && results.landmarks.length > 0) {
                analyzeGesture(results.landmarks[0]);
            }
            requestAnimationFrame(predict);
        };

        const analyzeGesture = (lm) => {
            const getDist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y, p1.z - p2.z);
            
            const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;
            const isV = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y;
            const isHeart = getDist(lm[4], lm[8]) < 0.04 && lm[12].y > lm[10].y;
            const isOpen = lm[8].y < lm[6].y && lm[20].y < lm[18].y;

            let prev = currentGesture;
            if (isFist) currentGesture = "saturn";
            else if (isV) currentGesture = "text";
            else if (isHeart) currentGesture = "heart";
            else if (isOpen) currentGesture = "rainbowSphere";

            if (prev !== currentGesture) {
                if(shapes[currentGesture]) shapes[currentGesture]();
                document.getElementById('gesture-label').innerText = `Detected: ${currentGesture}`;
            }
        };

        // --- Render Loop ---
        const animate = () => {
            requestAnimationFrame(animate);

            // Lerp particles to target
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                posAttr.array[i] += (targetPositions[i] - posAttr.array[i]) * 0.1;
                colAttr.array[i] += (targetColors[i] - colAttr.array[i]) * 0.1;
            }
            
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            
            points.rotation.y += 0.002;
            composer.render();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        setupHands();
        animate();

        window.toggleFullscreen = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        };

    </script>
</body>
</html>
